/*
<!DOC TYPE ?????
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello World from Needham MA</h1>
    <script src="index.js"></script>
</body>
</html> 

</meta> Divisible by 3 => Fizz
*/

// =========================================================
// [1] BASICS
// =========================================================
// 1 VARIABLES
let name;
console.log(name);              // by default undefined

let name = 'Mosh'               
console.log(name);
// rule1: cannot be reserved keyword
// rule2: should be meaningful, descriptive names
// rule3: cannot start with a number
// rule4: cannot contain a space of hyphen (-)
// rule5: are case-sensitive
// rule6: to declare multiple variables, two ways to do this
let firstName = 'Mosh', lastName = = 'Golhar';
// modern best practice, use seperate lines
let firstName = 'Mosh';
let lastName = = 'Golhar';

let firstName; // Camel case

// =========================================================
2 CONSTANTS


let interestRate1 = 0.4
interestRate1 = 1;
console.log(interestRate1);
// 1 on the console

// ==================

// if dont want variable to change, then use const
const interestRate2 = 0.4
interestRate2 = 1;
console.log(interestRate2);


// =========================================================
3 PRIMITIVE TYPES


Primitives / Value SVGUnitTypes

// list the types
String
Number
Boolean
undefined
null

// ==================

// 5 types of Primitive Types

let name = 'Mosh';          // String Literal
let age = 30;               // Number Literal
let isApproved = true;      // Boolean Literal
let firstName = undefined;  // Undefined
let selectedColor = null;   // Null


// ==================


let firstName;      // if not assigned, then its 'undefined'
console.log(firstName);         // undefined

let firstName = undefined;      // if not assigned, then its                undefined
console.log(firstName);         // console output is                        undefined

let selectedColor = null;       // in the beginning we assign it to null so use null in situations where we want to clear the value of a variable
let selectedColor = 'red';      // in the future we can reassign it to red

// ES6 introdued another Primitive called symbol, we teach this later in the course

// =========================================================
4 DYNAMIC TYPING

// Dynmaic Languages

// Static typed 
string name = 'John';       //this can not change in the future
// vs.
// Dynamic typed    
let name = 'John'           // this can change at run time

// ==================

// in VSCode we can type out
let name = 'Mosh';
let age = 30;
let isApproved = false;
let firstName = undefined;
let selectedColor = null;
// then in the console given this, we type 
// >typeof name             // 'string'
// >name = 1;               // 1
// >typeof name             // 'number'
// now clear console
// > typeof age             // 'number'
// > age = 30.1             // 30.1         // here we use a floating point number
// > typeof age             // 'number'     // what does this show? that all numbers are just numbers. There are no floating point numbers.

// ==================


let name = 'Mosh';
let age = 30;
let isApproved = false;
let firstName = undefined;
let selectedColor = null;

// in the console, 
// > typeof isApproved      // boolean
// > typeof firstName       // undefined        Notice that the value of this variable is undefined but its type is also undefined
//                                              what does this mean?
//                                              two categories of types Primitives/Value Types = Strings, Number, Boolean, undefined, null
//                                              so undefined is a type but its also a value
// so here we set firstName to THE VALUE undefined, its type is also undefined

// > typeof selectedColor   // objet

// what is an object? see next lecture

// =========================================================
5 OBJECTS

// ==================

// so you have seen all the Primitive Types in JavaScript,
// now lets look at the Reference Types

// Objects          we cover Objects after 4 CONTROL FLOW, 5 OBJECTS
// Arrays           we cover Arrays in 6 ARRAYS
// Functions        we cover Functions in 7 FUNCTIONS

// ==================

// Objects          we cover Objects after 4 CONTROL FLOW, 5 OBJECTS

        let name = 'Mosh';
        let age = 30;

        // we have two variables here, but we can also include these two variables INSIDE a PERSON object
        // start with let or const if we dont want to reassign the person object
        // so we set person to an OBJECT LITERAL
        //                      let person = {};
        // between the curly braces we add KEY VALUE PAIRS which the PROPERTIES OF THIS OBJECT
        // two keys which are name and age
        // so we add name then use colon : and set the value as 'Mosh' then add a comma and then another KEY VALUE PAIR
        // so now we have a PERSON OBJECT with TWO PROPERTIES OR TWO KEY VALUE PAIRS


        let person = {
            name: 'Mosh',
            age: 30
        };

        // now lets log the person on the console

        console.log(person);

        // in the console, we get the       > {name: 'Mosh', age: 30}
        // note the LITERAL SYNTAX
        // we have two KEY VALUE PAIRS and these are the properties of the person object

        // now there are two ways to access and change the name of the person

        // 1st way DOT NOTATION
        person.name = 'John';
        console.log(person.name);           // now in the console we get John

        // 2nd way BRACKET NOTATION
        // so we use [] square brackets and we pass the name of the TARGET PROPERTY

        let person = {
            name: 'Mosh',
            age: 30
        };

        // DOT NOTATION                     // more concise, shorter thus its our default choice
        person.name = 'John';

        // Bracket Notation                 // but sometimes you dont know the name to the TARGET PROPERTY UNTIL RUN TIME
        person['name'] = 'Mary'

        console.log(person.name);           // we get Mary in the console 

        // but sometimes you dont know the name to the TARGET PROPERTY UNTIL RUN TIME
        // for example in the user interface, the user might be selecting the name of the target property
        // thus in that case, at the time of writing code we dont know the name of the property the user will access as
        // this is selected at run time by the user.  So we might have another variable somewhere else like SELECTION
        // that determines the name of the target property that the user is selecting and this can change at run time.
        // Now with this, we can access that property using the bracket notation in a DYNAMIC WAY
        // so we pass selection here and we get the same result.        <<<<<SAME RESULT<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


        let person = {
            name: 'Mosh',
            age: 30
        };

        // DOT NOTATION
        person.name = 'John';

        // Bracket Notation
        let selection = 'name';             // add selection to represent user selection and then
        person[selection] = 'Mary'          // add selection inside the bracket notation.

        console.log(person.name);           // we get Mary in the console. <<<<<SAME RESULT<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

// =========================================================
6 ARRAYS

// ==================

// Arrays           we cover Arrays in 6 ARRAYS

        // somethimes you have a list of objects, use an array to store that list

        let selectedColors = [];        // initialize this with an ARRAY LITERAL and the [] square brackets indicate an empty array.

        let selectedColors = ['red', 'blue'];        // initialize this and add items red and blue

        // lets log this the console...

        let selectedColors = ['red', 'blue'];
        console.log(selectedColors);                // console shows our array with two elements ['red', 'blue']

        /*
        (2) ['red', 'blue']
        0: "red"                    // index of 1st element is 0
        1: "blue"                   // index of 2nd element is 1 so if we want to access an element in the array, we use this index
        length: 2
        [[Prototype]]: Array(0)
        */

        // to specify the 1st value in the array, we add the [] square brackets and specify the index #

        let selectedColors = ['red', 'blue'];
        console.log(selectedColors[0]);             // in the console we get red

        // JavaScript is a dynmaic language so the variables can change at run time. 
        // The same principles apply to our arrays.
        // So the length of an array as well as the types of objects we have in the array are dynamic (ie they can change).

        let selectedColors = ['red', 'blue'];      
        console.log(selectedColors[0]);           

        // we add another element to this array so the array will expand like this

        let selectedColors = ['red', 'blue'];   // here we initiliaze this array with two elements
        selectedColors[2] = 'green';            // add another element string to this array so the array expands
        console.log(selectedColors);            // console shows Â ['red', 'blue', 'green'] array with 3 elements

        // so now we an array with 3 elements
        // so the length is dynamic
        // also the type of objects we have in this array is also dynamic. 
        // So we can make the last element now a number thus we have two strings and a number

        let selectedColors = ['red', 'blue'];
        selectedColors[2] = 12;                 // add another element number to this array so the array expands
        console.log(selectedColors);            // console shows Â ['red', 'blue', 12]

        // so the objects in the array as well as the size of the array are dyanmic.

        // now techically the array is an object, so we can use the key value pairs or properties that we cann access using dot notation.
        // lets prove this to you using typeof 
        // in the console
        > typeof selectedColors
        > 'object'      // so the typeof this array is an object
        
        // now lets see the properties of this object using the DOT NOTATION
        let selectedColors = ['red', 'blue'];
        selectedColors[2] = 12;
        console.log(selectedColors.);            // console shows Â ['red', 'blue', 'green']
        //                        ^ using the dotation offer many properties to choose from INHERITANCE from PROTOTYPES

        console.log(selectedColors.);
        //                        ^
                                // every
                                // fill
                                // filter
                                // find
                                // findIndex
                                // forEach
                                // includes
                                // indexOf
                                // join
                                // keys
                                // lastIndexOf
                                // length           <========================================================================
                                // map
                                // pop
// these are all the properties using the dot notation
// using square brackets means that array will automatically receive thse properties
// we did NOT explicitedly define them. The somehow "magically" appeared --> inheritance. We learn this in Prototypes.

// now we look at one of these properties --> length property <==============================================================
        let selectedColors = ['red', 'blue'];
        selectedColors[2] = 12;
        console.log(selectedColors.length);         // now lets look a the length property which returns a 3 in the console
        // so here we learn an array a data structure that we use to represent a list of items.




// =========================================================
7 FUNCTIONS
// ==================

// Functions        we cover Functions in 7 FUNCTIONS

//lets define a function and inside {} is the body of the fucntion to hold function's logic

function greet() {}  

// ==================

// logic for the function is to display a message on the console

function greet() {                              // function declaration
    console.log('Hello World');  
}
  
greet();                                      // call the function AND add semicolon ; to indicate that this is a statement
  
// ==================

// greet function has 1 parameter called name and only meaningful inside of this function
// lets add a variable John
// we refer to this variable as a parameter
// name is an input to this function
// when calling greet function we need to pass a value for the name variable or name parameter more accurately
// we refer to 'John' as an argument


function greet(name) {                      // [2] need to pass in a value for the name parameter. Parameter is here at the time of declaration.
    console.log('Hello ' + name);  
}
  
greet('John');                              // [1] John is an argument to the greet function, so we pass this argument called John

// ==================

// IMPORTANT
// [1] John is an argument to the greet function
// [2] name is a parameter to the greet function
// note the difference between a parameter and an argument
// [2] a parameter is what we have here at the time of declaration
// [1] but the argument is the ACTUAL value that supply for that parameter


function greet(name) {
    console.log('Hello ' + name);  
}
  
greet('John');
greet('Mary');      // add a second argument here and pass this argument to the function


// ==================

// lets add a another parameter to the function which is lastName
// what happens is dont add anything to the function call? what happens?

function greet(name, lastName) {
    console.log('Hello ' + name + ' ' + lastName);  
}
  
greet('John');
greet('Mary');
  
// ==================


function greet(name, lastName) {
    console.log('Hello ' + name + ' ' + lastName);  
}
  
greet('John');
greet('Mary');
  
// note output as 
          // Hello John undefined
          // Hello Mary undefined
// note that the default value is undefined.

// ==================

function greet(name, lastName) {
    console.log('Hello ' + name + ' ' + lastName);  
}
  
greet('John', 'Smith');
  
// output now is Hello John Smith
  

// =========================================================
8 TYPES OF FUNCTIONS 

// later we use Template Literals to clean up this code

// Performing a task
function greet(name, lastName) {
    console.log('Hello ' + name + ' ' + lastName);  
}

// ==================
  
// Calculating a value
// takes in a parameter called number
function square(number) {}

// ==================

// now we need to calculate the square of that number
// return keyword is used to return the value to whoever is calling the function
// use that value to initialize a variable
function square(number) { 

}


// ==================


// Performing a task
function greet(name, lastName) {
    console.log('Hello ' + name + ' ' + lastName);  
}
  
// ==================

//Calculating a value
function square(number) {
return number * number;
}

let number = square(2);
console.log(number);


// ==================


// Performing a task
function greet(name, lastName) {
    console.log('Hello ' + name + ' ' + lastName);  
}

//Calculating a value
function square(number) {
return number * number;
}

console.log(square(2));

// dont need to actually declare seperate variable if all we need to do is display it on the console
// we can exclude the variable declartion and simply pass square(2) to console.log()
// so when the JavaScript executes this code, 1st it calls this function square(2), it will get a value, and then pass that value to console.log
  
// note that we actally have two function calls here. 1st is square(2) and 2nd is function square(number)

// Take Away: function is performs a task or calculates and returns a value. A real world applicaiton is essentially a collection of hundreds
//            thousands of functions working together to provide the functionality of that application.




// =========================================================
[3] OPERTATORS


// =========================================================
1 JavaScript Operators

// ==================

// 1 Arithemetic Operators      + - * / % **

// ==================

// 2 Arithemetic Operators 

let x = 10;
let y = 3;

console.log(x + y);     // x + y is an expression. An expression is something that produces a value.


let x = 10;
let y = 3;

console.log(x + y);
console.log(x - y);
console.log(x * y);
console.log(x / y);
console.log(x % y);
console.log(x ** y);

// ==================

let x = 10;
let y = 3;

// console.log(x + y);
// console.log(x - y);
// console.log(x * y);
// console.log(x / y);
// console.log(x % y);
// console.log(x ** y);

// Increment (++)
console.log(++x);       // value is incremented by 1 first then we see that on the console        11

// ==================

// Increment (++)
console.log(++x);       //  increments x by 1, THEN prints that to the console as 11

// ==================

// Increment (++)
console.log(x++);       // console.log prints 10 AND THEN increments x in memory but does NOT print that updated memory amount
                            10

// ==================

// Increment (++)
console.log(x++);       // prints 10 to the console, then increments x to 11 in memory
console.log(x);         // now if we include another console.log statement then it will show 10 and next line will show 11.

                            10
                            11


// ==================

// Decrement (--)

console.log(--x);       // decrement to variable x occurs in memory and then the console.log displays that

                            9

// ==================

// 3 Assignment Operators 

// ==================Basic starting point

let x = 10;

console.log(x);         // 10

x++;                    // reads x (into memory), increments by 1, and that new value is stored in memory

console.log(x);         // 11

// ==================


let x = 10;

x++;                    // reads x (into memory), increments by 1, and that new value is stored in memory
console.log(x);         // 11

x = x + 1;              // same thing here. reads x, then increments by 1, and that new value is stored into x


// ==================

let x = 10;

// x = x + 5;
x = x+5;                // x stays at 5

console.log(x);

// ==================


let x = 10;

// x = x + 5;
// console.log(x)

x += 5;
console.log(x)

// ================== 

// so all of prior lessons Arithmetic Operators are also applicable here.

let x = 10;

x = x + 5;
x += 5;     // addition assignment operator

x =  x * 3;   
x *= 3;      // multiplication assgnment operator


// 4 Comparison Operators


// ==================

let x = 1;

console.log(x > 0);   // comparison operator here. Result is a Boolean. Its true or false.

// ==================


let x = 1;

// Relational Operators
console.log(x > 0);       // true. comparison operator here. Result is a Boolean. Its true or false.
console.log(x >= 1);      // true.
console.log(x < 1);       // false 
console.log(x <= 1);      // true.

// ==================




let x = 10;
let y = x++;

console.log(y);     // 10 why? b/c y is assigned x then x is iterated.
console.log(x);     // 11 why? b/c x is iterated then stored in memory.





// 5 Equality Operators

// ==================

// Strict Equality Operator (assume both )
console.log(1 === 1 );

// Loose Equality Operator
console.log(1 == 1 );

// ==================

// what is the difference? (strict has three equals signs) (loose has two equal signs)

// Strict Equality Operator (Same Type and Same Value)
// Strict Equality Operator (assumes both Same Type and Same Value)

console.log(1 === 1 );

// Loose Equality Operator
console.log(1 == 1 );

// ==================


// what is the difference?

// Strict Equality Operator (Same Type and Same Value)
console.log(1 === 1 );        // number vs number
console.log('1' === 1 );      // string vs number

// Loose Equality Operator
console.log(1 == 1 );

// ================== 

// to focus on this, I will comment out these lines

// what is the difference?

// Strict Equality Operator (Same Type and Same Value)
// console.log(1 === 1);        // number vs number
// console.log('1' === 1);      // string vs number

// Loose Equality Operator
console.log(1 == 1);            // true
console.log('1' == 1);          // true

// why true. left side string, so automaticallly converts on right side to a string
console.log('1' == '1');
// thus you get true on the console


// ==================

// what is the difference?

// Strict Equality Operator (Same Type and Same Value)
// console.log(1 === 1);        // number vs number
// console.log('1' === 1);      // string vs number

// Loose Equality Operator
console.log(1 == 1);            // true
console.log('1' == 1);          // true
console.log(true == 1);          // true


// why true. left side string, so automaticallly converts on right side to a string
console.log('1' == '1');
// thus you get true on the console

// why true? same thing. left side a Boolean and this will convert the right side to a Boolean as well
// so its like comparing true with true:

console.log(true == 1);          // true
console.log(true == true);       // true


// ==================

// Strict Equality Operator (Same Type and Same Value) --> more precise and accurate
console.log(1 === 1);        // number vs number
console.log('1' === 1);      // string vs number

// Loose Equality Operator   (Value)
// (Does NOT care about the types matching. 
// If the types dont match then it will convert the type on the right TO MATCH what ever is on the left side).
// And then it will only check if the values are equal.

console.log(1 == 1);            // true
console.log('1' == 1);          // true
console.log(true == 1);          // true

// ==================

// 6 Ternary Operators (or Conditional Operators)

// explained (given a condition) ? itsthis otherwise itsthat
// ? "means if that condition evaluates to true" then its the first thing otherwise its the second thing

// ==================

// If customer more than 100 points, they are a 'gold' customer
// otherwise they are silver.

// track the points
let points = 90;
//         CONDITION                            start with a condition
//         ____________                         
//                      _                       if that condition evaluates to true
//                        ______                that customer is a gold customer
//                               _              otherwise
//                                 ________     that customer is a silver customer
let type = points > 100 ? 'gold' : 'silver';

console.log(type);                              // gold

// let points = 90;                             // silver

// ==================

// 7 Logical Operators

// ==================

// use these to make decisions based upon multiple conditions
// JavaScript has 3 types of operators: logical and, logical or, logical not
//                                      &&           ||

// Logical AND (&&)
// Returns TRUE if both operands ae TRUE
console.log(true && true);              // true

console.log(false && true);             // false

// Real world use case for this?
// build application for approving loans. If applicant has high income + good credit score

// ==================

let highIncome = true;
let goodCreditScore = true;

// so we are dealing with two conditions.
// so we can use the Logical AND

let highIncome = true;
let goodCreditScore = true;
let eligibleForLoan = highIncome && goodCreditScore;
//                    true       && true            --> both true so TRUE

// ==================

let highIncome = true;
let goodCreditScore = true;
let eligibleForLoan = highIncome && goodCreditScore;

console.log(eligibleForLoan);                         // true


// ==================



// Logical OR (||)
// Returns TRUE if one of the operands is TRUE
let highIncome = true;
let goodCreditScore = true;
let eligibleForLoan = highIncome || goodCreditScore;

console.log(eligibleForLoan);                         // true


// ==================

let highIncome = false;         // <<<<<<<<<<<<<<<<<<<<<<<<CHANGE
let goodCreditScore = true;
let eligibleForLoan = highIncome || goodCreditScore;

console.log(eligibleForLoan);                         // true

// ==================


// Logical OR (||)

// Returns TRUE if one of the operands is TRUE
let highIncome = true;
let goodCreditScore = false;     // <<<<<<<<<<<<<<<<<<<<<<<<CHANGE
let eligibleForLoan = highIncome || goodCreditScore;

console.log(eligibleForLoan);                         // true

// ==================

// Logical OR (||)
// Returns TRUE if one of the operands is TRUE
let highIncome = false;                 // <<<<<<<<<<<<<<<<<<<<<<<<CHANGE
let goodCreditScore = false;            // <<<<<<<<<<<<<<<<<<<<<<<<CHANGE
let eligibleForLoan = highIncome || goodCreditScore;

console.log(eligibleForLoan);                         // false  // <<<<<<<<<<<<<<<<<<<<<<<<CHANGE

// ==================


// NOT Operator
let highIncome = false;
let goodCreditScore = true;
let eligibleForLoan = highIncome || goodCreditScore;

// NOT (!)
let applicationRefused = !eligibleForLoan;             // note that you apply the NOT operator on the eligibleForLoan Boolean

console.log(eligibleForLoan);                         // true
console.log(applicationRefused);                      // false

// Logic - b/c if someone is eligible for a loan, then we DONT want to refuse their application.


// ==================


// Thus this person has low income and bad credit score.

let highIncome = false;
let goodCreditScore = false;
let eligibleForLoan = highIncome || goodCreditScore;
console.log('Eligible', eligibleForLoan);

// NOT (!)
let applicationRefused = !eligibleForLoan;
console.log('Application Refused', applicationRefused);


/*
Eligible false
Applicaiton Refused true
*/

// ==================


// 8 Logical Operators with Non-booleans

// ==================

// JavaScript offer NonBoolean operators to be used with Boolean operators
// Extremely powerful --> TRUTHY and FASLY
// JavaScript engine will look at the boolean expression and try to interpret it

/*
false || true       // true 
false || 'Mosh'     // 'Mosh'               
false || 1          //1                   */

// ==================

// Falsy (false)
// undefined      
// null   
// 0        
// false    
// ''       empty string
// NaN      Not a Number

// Anything that is not Falsy --> Truthy

// ==================

// so here our second OPERAND is a string wtih 4 characters. 
// SO THIS IS NOT AN EMPTY STRING, so its not falsy, thus it is TRUTHY

// false || 'Mosh'     // 'Mosh' 

// so when our JavaScript engine tries to evalate this, 
// it looks at the first operand, it is false, so the search continues
// b/c with the logical or operator
// as you learned in the last lecture
// b/c one of the operands is TRUE thus the result will be TRUE.

// ==================

// The same is here for the 3rd example. 
// The 1 is a not a boolean true, rather it is truthy, and that is why the value 
// of this operand is returned


// false || 1           // 1


// ==================

// false || 1 || 2      // 1

// This returns 1
// The logical OR operator.
// The evaluation starts here, and as soon as we find an operand that is truthy, then that operand is returned.
// So here the second operand is truthy, its value is returned, and thus the evaluation stops. The evaluation does
// not continue onto the 3rd operand. There could be a million other operands, but they are all ignored once the 
// evaluation finds a trthy operand.
// This is what we all SHORT CIRCUTING.

// Short-curcuiting

// Real world example
// Building an application. User needs to pick a color otherwise we use a default color.

// ==================

let userColor = 'red';
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;   // if user gives a color choice otherwise defaultColor

console.log('currentColor is ' + currentColor);      // red
console.log('userColor is ' + userColor);

/*
let userColor;                  // undefined
console.log(currentColor);      // blue

let userColor = '';             // screen is blank
console.log(currentColor);      // blue

let userColor = undefined;      // undefined
console.log(currentColor);      // blue

let userColor = '3';
console.log(currentColor);      // 3 (wrong, input validation needed)
*/


// 9 Bitwise Operators

// similiar to logical operators but they work in the individual bits

// 1 = 00000001
// 2 = 00000010
// 3 = 00000011


// Bitwise OR  
console.log(1 | 2);     // 3
// why? 1st digit 1 or 0 yields 1, 2nd digit 0 or 1 yields 1. 
// Thus 1st digit is 1, 2nd digit is 1 thus 00000011 which is 3

// Bitwise AND
console.log(1 & 2);     // 0
// 1st digit: 1 & 0 is 0
// 2nd digit: 0 & 1 is 0
// thus 1st digit is 0 and 2nd digit is 0 thus its 00000000 which translates to 0.

// ==================

// 1 = 00000001
// 2 = 00000010
// 3 = 00000011

// Read, Write, Execute
// 00000 1 0 0     Read only
// 00000 1 1 0     Read and Write
// 00000 1 1 1     Read, Write, Execute

const readPermission = 4;
const writePermission = 2;
const executePermission = 1;

/*        1 2 3 4 5 6 7 8 <----digit
1	1       0 0 0 0 0 0 0 0 <----1 
2	10      0 0 0 0 0 0 0 1 <----2
3	11      0 0 0 0 0 0 1 0 <----3
4	100     0 0 0 0 0 1 0 0 <----4        <---- Read Only             4
5	101     0 0 0 0 0 1 0 1 <----5 
6	110     0 0 0 0 0 1 1 0 <----6        <---- Read Write            2
7	111     0 0 0 0 0 1 1 1 <----7        <---- Read Write Execute    1
8	1000    0 0 0 0 1 0 0 0 <----8
9	1001    0 0 0 0 1 0 0 1 <----9
10	1010  0 0 0 0 1 0 1 0 <----10
*/

let myPermission = 0;
myPermission = myPermission | readPermission | writePermission;   // 0 + 4 + 2
console.log(myPermission);                                        // 6


// ==================

let myPermission = 0;
myPermission = myPermission | readPermission | writePermission;   // 0 + 4 + 2

let message = 
  (myPermission & readPermission) ? 'yes' : 'no';
  console.log(message);     // yes


// ==================

let myPermission = 0;
myPermission = myPermission | writePermission;   // 0 + 2

let message = 
  (myPermission & readPermission) ? 'yes' : 'no';
  console.log(message);     // no  
  
// why no? notice that myPermission only has a 0 and a Write. this is also 0 + 2. Not a read (which would be a 4).
// Thus MyPermission & readPermission       evaluates to NO.

// ==================

let myPermission = 0;
myPermission = myPermission | readPermission | writePermission;   // 0 + 4 + 2

let message = 
  (myPermission & executePermission) ? 'yes' : 'no';
  console.log(message);     // no

/*
So what is important here? 
With the BitWise OR Permission we can add permissions.
With the Bitwise AND Permission we can check to see if we have a given permission.
*/

// ==================


// 10 Operators Precedence          + 1 * / % ** 

// 11 Quiz

// 12 Exercise Swapping Variables

// Swap Variable Colors

let a = 'red';
let b = 'blue';

console.log('Original a = ' + a);
console.log('Original b = ' + b);

let c = a;        // c = 'red' thus both c and a are BOTH red and now can update a to new color
a = b;            // a = takes on b color of 'blue'
b = c;            // b = takes on c color

console.log('Swapped: a = ' + a);
console.log('Swapped: b = ' + b);



// ==================

// ==================

// ==================

// ==================

// ==================

// ==================

// ==================

// ==================

// ==================




// =========================================================
2 Arithmetic Operators 

// =========================================================
3 Assignment Operators 

// =========================================================
4 Comparision Operators 

// =========================================================
5 Equality Operators 

// =========================================================
6 Ternary Operators 

// =========================================================
7 Logical Operators 

// =========================================================
8 Logical Operators with Non-Booleans

// =========================================================
9 Bitwise Operators 

// =========================================================
10 Operators Precedence


















// Objects          we cover Objects after 4 CONTROL FLOW, 5 OBJECTS
    /*
    Basics
    Factory Functions
    Constructor Functions
    Dynamic Nature of Objects
    Constructor Property
    Functions are Objects
    Value vs Reference Types
    Enumerating Properties of an Object
    Cloning an Object
    Garbage Collection
    Math
    String
    Template Literals
    Date
    Exercise 1 - Address Object
    Exercise 2 - Factory and Constructor Functions
    Exercise 3 - Objet Equality
    Exericse 4 - Blog Post Object
    Exercise 5 - Constructor Functions
    Exercise 6 - Price Range Object
    Quick Note
    */

// Arrays           we cover Arrays in 6 ARRAYS
    /*
    Introduction
    Adding Elements
    Finding Elements (Primitives)
    Finding Elements (Reference Types)
    Arrow Functions
    Removing Elements
    Empyting an Array
    Combining and Slicing Arrays
    Spread Operator
    Iterating an Array
    Joining an Array
    Sorting an Array
    Testing the Elements of an Array
    Filtering an Array
    Reducing an Array
    Exercise 1 - Array from Range
    Exercise 2 - Includes
    Exercise 3 - Except
    Exercise 4 - Moving an Element
    Exercise 5 - Count Occurrences
    Exercise 6 - Get Max
    Exercise 7 - Movies
    */

// Functions        we cover Functions in 7 FUNCTIONS
    /*
    Function Declarations vs Expressions
    Hoisting
    Arguments
    Rest Operator
    Default Parameters
    Getters and Setters
    Try and Catch
    Local vs Global Scope
    Let vs Var
    this Keyword
    Changing this
    Exercise 1 - Sum of Arguments
    Exercise 2 - Area of Circle
    Exercise 3 - Error Handling
    Wrap Up
    Whats Next (Part 2 JavsScript Course)
    */








// =========================================================
// =========================================================
// =========================================================
// =========================================================
// =========================================================
// =========================================================
// =========================================================
// =========================================================
// =========================================================





// Divisible by 5 => Buzz
// Divisible by both 3 and 5 ==> FizzBuzz
// Not divisible by 4 or 5 ==> input
// Not a number ==> 'Not a number'

const output = 3;
console.log(output);


============================================================

//=========================================================================
// [4] CONTROL FLOW
//=========================================================================

//=========================================================================
// [4] CONTROL FLOW #1 If ... else
// Problem Set
// Hour
// Depending upon its value, we greet the user with different message
//      if hour is between 6am and 12pm, display Goor morning!
//      if hour is between 12pm and 6pm, display Good afternoon!
//      otherwise: Good evening!
// Now need this logic so use        if... else
if (condition)                  // if the condition evaluates to true, then the statement after will be executed
    statement

if (condition) {                // if have multiple statements to be executed, then put them inside a "block of code" using curly brackets 
    statement
}
else if (anotherCondition)      // if have another condition then use else if with anotherCondition and then the statement
    statement 

else if (yetAnotherCondition)   // yet another condition. Can has as many conditions as needed
    statement
// now if none of the above statements evaluates to true then we can use else to execute one or more statements
else 
    statement

// Now take this logic and map into this structure. 
//      if hour is between 6am and 12pm, display Goor morning!
//      if hour is between 12pm and 6pm, display Good afternoon!
//      otherwise: Good evening!

// condition is         if hour is between 6am and 12pm
// statement is         display Goor morning!

so let hour = 10;       // in real world application we would want to read the current hour, but here lets not worry about that
                        // so we hard code this number 10
// so we want to compare the value of hour 10 with 6am and 12pm
// for simplicity lets go with 24 hour time format










//=========================================================================

// [4] CONTROL FLOW #12 Exercise 4 FizzBuzz
// FizzBuzz

// LOGIC
// Divisible by 3 => Fizz
// Divisible by 5 => Buzz
// Divisible by both 3 and 5 ==> FizzBuzz
// Not divisible by 3 or 5 ==> input
// Not a number ==> return 'Not a number' NaN
// pass false in 
// typeof NaN
 
const output = 3;
console.log(output);

// if typeof input is not a number then return 'Not a number'
// use typeof

// if input % 3 === 0 return Fizz
// if input % 5 === 0 return Buzz
// if input % 3 && % 5 return FizzBuzz
// () && ()
// return input
// hint watch ordering of if statements. Move && up using ALT Up Arrow

//=========================================================================
// [4] CONTROL FLOW #13 Exercise 5 Demerit Points

// LOGIC
// Speed Limit = 70
// 5 -> 1 point
// use Math.floor(1.3)  -> 1        Floating Point Numbers
// 12 points -> license suspended

// create function checkSpeed
// define a const speedLimit = 70
// tip test your function with different values

// call the function
checkSpeed(70);

function checkSpeed(speed) {
}
// bug speed at 70, add in =

// tip avoid indentation if you can b/c then may need to scroll left right
//     so add a code block {}, move up code into the block, and add a return to
//     jump out of the function thus none of the rest of the code gets executed
//     thus able to delete the else statement, and remove the indentation

//=========================================================================
// [4] CONTROL FLOW #14 Exercise 6 Even Odd Numbers 
// LOGIC

showNumbers(10);
function showNumbers(limit)
//

//=========================================================================
// [4] CONTROL FLOW #15 Count Truthy takes an array and returns the number of truthy values in the array
// LOGIC
// call countTruthy, pass this array, count the number of truthy values, and immediately pass the result to console.log



//=========================================================================
// [4] CONTROL FLOW #16 Exercise 1 Max of Two Numbers
//=========================================================================
// [4] CONTROL FLOW #16 Exercise 2 Landscape or Portrait
//=========================================================================
// [4] CONTROL FLOW #16 Exercise 3 FizzBuzz
//=========================================================================
// [4] CONTROL FLOW #16 Exercise 4 Demerit Points
//=========================================================================
// [4] CONTROL FLOW #16 Exercise 5 Even and Odd Numbers
//=========================================================================
// [4] CONTROL FLOW #16 Exercise 6 String Properties


//=========================================================================

// [4] CONTROL FLOW #16 Exercise 7 String Properties
// LOGIC
// showProperties(obj)
// pass this function an object and this function should display all the properties of the object that are of type string

const movie = {
    title: 'a',
    releaseYear: 2018,
    rating: 4.5,
    director: 'b'
};

showProperties(movie);      // call the function showProperties and pass in the movie object, lets see what we get. Output shows two strings

function showProperties(obj) {
    for (let key in obj)
    console.log(key);
    // check the type of key
    // then display all the properties of the obj that are of type string
}

// use the For...in loop to iterate over the object
// in each iteration the key will hold that name of the property

// to get the value of each property using [] notation
// use typeof operator and put into if statement

function showProperties(obj) {
    for (let key in obj)
        obj[key]           // to get the value of each property using [] notation so type in obj[key]
}

                            // to check the type of this value, use the typeof operator
                            // then put into an if statement
                            // so then if the typeof obj of key === 
                            // 'string'
                            // then simply display console.log of key as well as object of key

function showProperties(obj) {
    for (let key in obj)
        if (typeof obj[key] === 'string')           // to get the value of each property using [] notation
            console.log(key, obj[key]);             // then simply display console.log of key as well as object of key
}

// save the changes
// and should yield the title and director properties along with their values

// note we dont use {} as part of the for statement b/c we only have a single statement under the for statement
// why? the if statement and console.log statement is really one statement.// but can use {} as its perfectly fine.


//=========================================================================
// [4] CONTROL FLOW #17 Exercise 8 Sum of Multiples 3 and 5
// LOGIC

// returns the sum of all the multiples of 3 and 5 up to the limit
// example limit is 10
// Mutiples of 3: 3, 6, 9
// Multiples of 5: 5 + 10
// Sum = 33

console.log(sum(10));

function sum(limit) {

}

// start with a for loop
// let i = 0 as long as i is less than or equal to limit, then increment i
// now we check to see if i is a mulitple of 3 of 5

function sum(limit) {
    for (let i = 0; i <= limit; i++)        
}

// now we check to see if i is a mulitple of 3 of 5
// so if i moduls 3 equals 0 
// or
function sum(limit) {
    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 )
}   

// or i modulus 5 equals 0 
function sum(limit) {
    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 || i % 5 === 0)
}   


// now we need take i and add it to our sum
// here we need to declare a variable
// let sum = 0;
// and if i is a multiple of 3 or 5 then add i to sum
function sum(limit) {
    let sum = 0;

    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 || i % 5 === 0)

}   


// and if i is a multiple of 3 or 5 then add i to sum
function sum(limit) {
    let sum = 0;

    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 || i % 5 === 0)
            sum += i;
}


// and if i is a multiple of 3 or 5 then add i to sum
// and finally, return sum;
function sum(limit) {
    let sum = 0;

    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 || i % 5 === 0)
            sum += i;

    return sum;
}


// Mutiples of 3: 3, 6, 9
// Multiples of 5: 5 + 10
// Sum = 33
function sum(limit) {
    let sum = 0;                                // initialization

    for (let i = 0; i <= limit; i++)            // logic
        if (i % 3 === 0 || i % 5 === 0)
            sum += i;

    return sum;                                 // return
}

// pay attention to how seperated (line breaks) this code: initialization, logic, return
// if didnt do this then the code looks squashed, hard to read
function sum(limit) {
    let sum = 0;
    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 || i % 5 === 0)
            sum += i;
    return sum;
}

// tips
// always have last line seperated 
// keep logic together



//=========================================================================
// [4] CONTROL FLOW #18 Exercise 9 Grade
// LOGIC

const marks = [80, 80, 50];

// Average = 70


// 0-59: F
// 60-69: D
// 70-79: C
// 80-89: D
// 90-100: A

console.log(calculateGrade(marks));

function calculateGrade(marks) {

}

// first calculate avg mark
// to do this, need to declare variable sum, initialize it to 0
// then use for of loop to iterate this array of marks, and calculate the sum of all
// so let mark of marks 
// then add it to sum so sum += mark
// so this is the total
// so need to get the avg
// then use the table to get the grade.

function calculateGrade(marks) {
    let sum = 0;
    for (let mark of marks)
        sum += mark;
        let average = sum / marks.length;

        if (average < 60) return 'F';
        if (average < 70) return 'D';
        if (average < 80) return 'C';
        if (average < 90) return 'B';
        return 'A';        
}


// checking the upper limit each time
if (average < 60) return 'F';
if (average < 70) return 'D';
if (average < 80) return 'C';
if (average < 90) return 'B';
return 'A';

// SINGLE RESPONSIBILITY PRINCIPLE --> restaurant, chef only resp for cooking, manager only resp for managing the rest
// have functions that are small and only focused on one thing
// here
// first part is about calculating avg in an array
// second part is about calculating grade

function calculateGrade(marks) {
    let sum = 0;
    for (let mark of marks)
        sum += mark;
        let average = sum / marks.length;
}


function calculateAverage(array) {
    let sum = 0;
    for (let value of array)
        sum += value;
        let average = sum / array.length;
        return average;
}





// now we have two very simple functions and 
// each functions is responsible for only one thing

function calculateGrade(marks) {
    const average = calculateAverage(marks);
    if (average < 60) return 'F';
    if (average < 70) return 'D';
    if (average < 80) return 'C';
    if (average < 90) return 'B';
    return 'A';
}    

function calculateAverage(array) {
    let sum = 0;
    for (let value of array)
        sum += value;
    return sum / array.length;      // even simplier vs above block
}



//=========================================================================
// [4] CONTROL FLOW #19 Exercise 10 showStars
// given
showStars(10);

function showStars(rows){

}

// output
// *
// **
// ***
// ****
// *****
// ******
// *******
// ********
// *********
// **********

// LOGIC
// let max = 10;
// for (i = 0; i <= max; i++)
//      console.log

function sum(limit) {
    let sum = 0;
    for (let i = 0; i <= limit; i++)        
        if (i % 3 === 0 || i % 5 === 0)
            sum += i;
    return sum;
}

// MOSH
// start with for loop
// we set this row to 1, as long as row is <= rows, we increment row and pattern starts empty
// 
// now in each row, depending on the # of rows, we need to display the number of stars
// so here lets declare a variable called pattern and set to an empty string
// so now depending on the value of the row, we need to add one or more stars to the pattern
// so need another for loop, for let i = 0, as long as i is < row, increment i++
// add here we add a * to the pattern
//      NEED A NESTED LOOP
//      so 2nd for loop will start at 0 and we run this while i is less than row, and each time we append one star to the empty string pattern
//      when we are done with each iteration, we console.log that existing pattern

showStars(10);

function showStars(rows) {
    for (let row = 1; row <= rows; row++) {
        let pattern = ''; 
        for (let i = 0; i < row; i++)
            pattern += '*';
        console.log(pattern);
    }
}


//=========================================================================
// [4] CONTROL FLOW #20 Exercise 10 Prime Numbers

// output
// 2
// 3
// 5
// 7
// 11
// 13
// 17
// 19

// given 
// Prime (whose factors are only 1 and itself)
// 11 = 1, 11
// 13 = 1, 13
// Composite
// 12 = 1, 2, 3, 4, 6, 12

showPrimes(20);

function showPrimes(limit)

// LOGIC







//=========================================================================


